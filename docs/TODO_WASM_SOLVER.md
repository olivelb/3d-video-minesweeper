# ğŸ¦€ WASM Solver â€” Implementation Plan

> **Goal:** Port the computationally intensive solver/generation pipeline to WebAssembly (Rust) for 3â€“15Ã— speedup on both client (browser) and server (Raspberry Pi 3).  
> **Scope:** `MinesweeperSolver`, `GaussianElimination`, and `placeMines` + `calculateNumbers` board generation loop.  
> **Language:** Rust, compiled to WASM via `wasm-pack` (browser) and native Node.js via `napi-rs` or WASM-in-Node.  
> **Principle:** The JS versions remain as fallback â€” WASM is progressively loaded.

---

## ğŸ“ Architecture Overview

```
shared/
â”œâ”€â”€ MinesweeperSolver.js          â† EXISTING (JS fallback, untouched)
â”œâ”€â”€ GaussianElimination.js        â† EXISTING (JS fallback, untouched)
â”œâ”€â”€ solver-wasm/                  â† NEW Rust crate
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs                â† wasm-bindgen entry point + JS API
â”‚   â”‚   â”œâ”€â”€ board.rs              â† Board struct, mine placement, number calculation
â”‚   â”‚   â”œâ”€â”€ solver.rs             â† All 5 solving strategies
â”‚   â”‚   â”œâ”€â”€ gaussian.rs           â† Gaussian Elimination (RREF + reasoning)
â”‚   â”‚   â”œâ”€â”€ types.rs              â† Shared types (CellKey, Grid, Neighbor cache)
â”‚   â”‚   â””â”€â”€ rng.rs                â† WASM-compatible RNG (xoshiro256**)
â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â””â”€â”€ solver_tests.rs       â† Equivalence tests vs JS outputs
â”‚   â””â”€â”€ pkg/                      â† AUTO-GENERATED by wasm-pack
â”‚       â”œâ”€â”€ solver_wasm.js         â† JS glue (ESM)
â”‚       â”œâ”€â”€ solver_wasm_bg.wasm    â† Compiled WASM binary
â”‚       â””â”€â”€ solver_wasm.d.ts       â† TypeScript declarations
â””â”€â”€ SolverBridge.js               â† NEW: Unified API, lazy-loads WASM or falls back to JS
```

### Data Flow (Board Generation, No-Guess mode)

```
Game.placeMines()
  â”‚
  â”œâ”€â”€ WASM available?
  â”‚     YES â†’ SolverBridge.generateSolvableBoard(width, height, bombCount, safeX, safeY)
  â”‚            â””â”€â”€ Entire loop runs inside WASM (no JSâ†”WASM per-iteration)
  â”‚            â””â”€â”€ Returns: { mines: Uint8Array, grid: Int8Array, attempts: number }
  â”‚
  â”‚     NO  â†’ Existing JS path (MinesweeperSolver.isSolvable loop)
  â”‚
  â””â”€â”€ Populate this.mines, this.grid, this.visibleGrid from result
```

---

## âœ… Phase 0 â€” Prerequisites & Toolchain Setup

- [ ] **0.1** Install Rust toolchain (`rustup`) with `wasm32-unknown-unknown` target
  ```bash
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
  rustup target add wasm32-unknown-unknown
  cargo install wasm-pack
  ```
- [ ] **0.2** Verify `wasm-pack build --target web` works with a hello-world crate
- [ ] **0.3** Add `shared/solver-wasm/` to `.gitignore` for `pkg/` and `target/` dirs
  ```gitignore
  # WASM build artifacts
  shared/solver-wasm/target/
  shared/solver-wasm/pkg/
  ```
- [ ] **0.4** Create build script / npm script for convenience
  ```json
  // In root package.json (or a Makefile)
  "scripts": {
    "build:wasm": "cd shared/solver-wasm && wasm-pack build --target web --out-dir pkg"
  }
  ```

**DoD:** `wasm-pack build --target web` produces a working `.wasm` + `.js` in `pkg/`.

---

## âœ… Phase 1 â€” Core Types & Grid Representation (`types.rs`, `board.rs`)

### 1.1 â€” `types.rs`: Shared data structures

- [ ] **1.1.1** Define `Grid` struct â€” flat `Vec<i8>` with `width Ã— height`, column-major (matching JS `grid[x][y]`)
  ```rust
  pub struct Grid {
      pub width: usize,
      pub height: usize,
      pub cells: Vec<i8>,  // grid values: 0=empty, 1=mine, 2-8=number counts
  }
  impl Grid {
      pub fn new(width: usize, height: usize) -> Self { ... }
      pub fn get(&self, x: usize, y: usize) -> i8 { self.cells[x * self.height + y] }
      pub fn set(&mut self, x: usize, y: usize, val: i8) { self.cells[x * self.height + y] = val; }
  }
  ```

- [ ] **1.1.2** Define `VisibleGrid` â€” flat `Vec<i8>`, -1 = hidden, 0-8 = revealed number, 9 = exploded
  ```rust
  pub struct VisibleGrid {
      pub width: usize,
      pub height: usize,
      pub cells: Vec<i8>,  // -1 = hidden
  }
  ```

- [ ] **1.1.3** Define `Flags` â€” flat `Vec<bool>` (or `Vec<u8>` for WASM efficiency)

- [ ] **1.1.4** Define `NeighborCache` â€” pre-computed `Vec<Vec<(usize, usize)>>` indexed by `x * height + y`
  ```rust
  pub struct NeighborCache {
      width: usize,
      height: usize,
      // neighbors[x * height + y] = vec of (nx, ny) pairs
      neighbors: Vec<Vec<(usize, usize)>>,
  }
  impl NeighborCache {
      pub fn new(width: usize, height: usize) -> Self { /* pre-compute all 8-neighbors */ }
      pub fn get(&self, x: usize, y: usize) -> &[(usize, usize)] { ... }
  }
  ```

- [ ] **1.1.5** `cell_key(x, y) -> u32` and `decode_key(key) -> (usize, usize)` â€” bit-packed, matching JS `(x << 16) | y`

### 1.2 â€” `board.rs`: Mine placement & number calculation

- [ ] **1.2.1** `fn place_mines_random(width, height, bomb_count, safe_x, safe_y, safe_radius, rng) -> Vec<bool>`
  - Generates a `Vec<bool>` (mines array) with `bomb_count` mines
  - Excludes the safe zone around `(safe_x, safe_y)` with the given radius
  - Uses the WASM-compatible RNG from `rng.rs`
  - Must match the statistical behavior of the JS version

- [ ] **1.2.2** `fn calculate_numbers(mines: &[bool], width, height) -> Vec<i8>`
  - For each non-mine cell, count adjacent mines
  - Returns grid values (0-8 for numbers, stored value for mines)
  - **This is the grid[x][y] equivalent**

- [ ] **1.2.3** `fn generate_solvable_board(width, height, bomb_count, safe_x, safe_y, no_guess, max_attempts) -> BoardResult`
  - **The big loop** â€” replaces the `do { ... } while (!isSolvable)` in `Game.placeMines()`
  - Returns:
    ```rust
    pub struct BoardResult {
        pub mines: Vec<bool>,     // flat, column-major
        pub grid: Vec<i8>,        // number grid
        pub attempts: u32,        // how many tries it took
        pub success: bool,        // false if max_attempts reached
    }
    ```
  - **Key benefit:** The entire retry loop runs inside WASM â€” no JSâ†”WASM boundary per iteration

### 1.3 â€” `rng.rs`: WASM-compatible random number generator

- [ ] **1.3.1** Implement `xoshiro256**` or use `rand` crate with `wasm-bindgen` feature
  - Seedable for reproducibility (important for multiplayer determinism)
  - Must support `gen_range(0..width)` efficiently
  - Consider using `getrandom` crate with `"js"` feature for browser entropy

**DoD:** `board.rs` can generate a valid board with correct numbers. Unit tests pass comparing output to known JS-generated boards.

---

## âœ… Phase 2 â€” Solver Strategies (`solver.rs`)

Each strategy is ported 1:1 from the JS, operating on the flat `Grid`/`VisibleGrid`/`Flags` structs.

### 2.1 â€” Strategy 1: Basic Rules

- [ ] **2.1.1** Port `applyBasicRules()` â†’ `fn apply_basic_rules(...) -> SolverStepResult`
  - Operates on dirty cells (passed as `HashSet<u32>`)
  - Returns `{ progress: bool, flag_count: u32, dirty_cells: HashSet<u32> }`
  - Key change: Instead of JS `Set<number>`, use `HashSet<u32>` or `FxHashSet<u32>` (faster hashing)

### 2.2 â€” Strategy 2: Subset Logic

- [ ] **2.2.1** Port `applySubsetLogic()` â†’ `fn apply_subset_logic(...) -> SolverStepResult`
  - Constraint cell data stored as struct with pre-computed hidden sets
  - Subset checking uses `HashSet::is_subset()` â€” native Rust is much faster here

### 2.3 â€” Strategy 3: Gaussian Elimination

- [ ] **2.3.1** Port `GaussianElimination.getConnectedComponentsOptimized()` â†’ `fn get_components(...)` 
  - Uses flat `Vec<u8>` frontier map (same as JS `Uint8Array`)
  - BFS with pre-allocated queue

- [ ] **2.3.2** Port `GaussianElimination.solveComponent()` â†’ `fn solve_component(...)`
  - Matrix stored as `Vec<Vec<f32>>` (matching JS `Float32Array`)
  - Variable index map as `Vec<i16>` (matching JS `Int16Array`)

- [ ] **2.3.3** Port `GaussianElimination.computeRREF()` â†’ `fn compute_rref(matrix: &mut [Vec<f32>], m: usize, n: usize)`
  - **This is the most critical hot loop** â€” row operations on dense matrices
  - Consider using SIMD intrinsics for row subtraction (future optimization)

- [ ] **2.3.4** Port `GaussianElimination.solveLargeComponent()` â†’ `fn solve_large_component(...)`
  - Sliding window with overlap, delegates to `solve_component()`

- [ ] **2.3.5** Port top-level `GaussianElimination.solve()` â†’ `fn gaussian_solve(...)`
  - Orchestrates component decomposition + per-component solving

### 2.4 â€” Strategy 4: Proof by Contradiction

- [ ] **2.4.1** Port `checkContradiction()` â†’ `fn check_contradiction(...) -> bool`
  - **Key optimization:** In Rust, the simulated flags/revealed state can use stack-allocated `HashMap` (or `FxHashMap`) instead of JS `Map` closures â€” much faster allocation
  - Localized propagation with BFS

- [ ] **2.4.2** Port `solveByContradiction()` â†’ `fn solve_by_contradiction(...) -> ContradictionResult`
  - Frontier limited to 50 cells (matching JS)

### 2.5 â€” Strategy 5: Tank Solver

- [ ] **2.5.1** Port `groupFrontierRegions()` â†’ `fn group_frontier_regions(...)`
  - BFS-based connected component grouping

- [ ] **2.5.2** Port `getRegionConstraints()` â†’ `fn get_region_constraints(...)`
  - Build constraint structs with cells-in-region indices

- [ ] **2.5.3** Port `enumerateConfigurations()` â†’ `fn enumerate_configurations(...)`
  - Bit-mask enumeration `0..2^n`
  - **Rust advantage:** `u32::count_ones()` for popcount is a single CPU instruction

- [ ] **2.5.4** Port `analyzeConfigurations()` â†’ `fn analyze_configurations(...)`
  - Find always-mine / always-safe cells across valid configs

### 2.6 â€” Strategy 6: Global Mine Count

- [ ] **2.6.1** Port `applyGlobalMineCount()` â†’ `fn apply_global_mine_count(...)`
  - Simple scan: if remaining_mines == hidden_cells or remaining_mines == 0

### 2.7 â€” Top-level solver

- [ ] **2.7.1** Port `isSolvable()` â†’ `fn is_solvable(grid, width, height, bomb_count, start_x, start_y) -> bool`
  - Orchestrates all strategies in order
  - Runs the main loop with dirty cell tracking

- [ ] **2.7.2** Port `simulateReveal()` â†’ `fn simulate_reveal(...)`
  - Stack-based flood fill (same algorithm as JS)

- [ ] **2.7.3** Port `getFrontier()` â†’ `fn get_frontier(...)`
  - Scan for hidden cells adjacent to revealed numbers

- [ ] **2.7.4** Port `getHint()` â†’ `fn get_hint(...)` â†’ `Option<Hint>`
  - Frontier + island hint finding
  - Returns `{x, y, score, type}` or None

**DoD:** All 6 strategies produce identical results to the JS version on a set of 100+ test boards. `is_solvable()` returns the same boolean as `MinesweeperSolver.isSolvable()` for all test cases.

---

## âœ… Phase 3 â€” WASM Bindings (`lib.rs`)

### 3.1 â€” Exported WASM functions

- [ ] **3.1.1** Export `generate_solvable_board(width, height, bomb_count, safe_x, safe_y, safe_radius, max_attempts) -> JsValue`
  ```rust
  #[wasm_bindgen]
  pub fn generate_solvable_board(
      width: u32, height: u32, bomb_count: u32,
      safe_x: u32, safe_y: u32, safe_radius: u32,
      max_attempts: u32,
  ) -> JsValue {
      // Returns a JS object: { mines: Uint8Array, grid: Int8Array, attempts: u32, success: bool }
  }
  ```
  - **This is the primary API** â€” one call replaces the entire async `placeMines()` loop
  - Mines/grid returned as typed arrays for zero-copy transfer

- [ ] **3.1.2** Export `is_solvable(grid_flat, width, height, bomb_count, start_x, start_y) -> bool`
  - Takes a flat `Int8Array` grid representation
  - For cases where the caller wants to check solvability separately

- [ ] **3.1.3** Export `get_hint(grid_flat, visible_flat, flags_flat, mines_flat, width, height) -> JsValue`
  - Returns `{ x, y, score, type }` or `null`
  - For the in-game hint button

- [ ] **3.1.4** Export `calculate_numbers(mines_flat, width, height) -> Int8Array`
  - Standalone utility for computing neighbor counts
  - Used by multiplayer `prePlaceMinesForMultiplayer()` if needed

### 3.2 â€” Data marshalling strategy

- [ ] **3.2.1** Input: JS passes flat typed arrays (`Uint8Array`, `Int8Array`)
  - Grid: `Int8Array[width * height]` (column-major: `grid[x * height + y]`)
  - Mines: `Uint8Array[width * height]` (0 or 1)
  - Flags: `Uint8Array[width * height]` (0 or 1)
  - VisibleGrid: `Int8Array[width * height]` (-1 for hidden)

- [ ] **3.2.2** Output: WASM returns results via `serde_wasm_bindgen` or manual `JsValue` construction
  - For `generate_solvable_board`: return `{ mines: Uint8Array, grid: Int8Array, attempts, success }`
  - For `get_hint`: return `{ x, y, score, type }` object or `null`

- [ ] **3.2.3** Document the column-major layout convention clearly in both Rust and JS
  ```
  // Convention: cells[x * height + y] maps to grid[x][y]
  // This matches the JS grid which is Array(width) of Array(height)
  ```

**DoD:** `wasm-pack build --target web` succeeds. The JS glue code can be imported in a browser ES module.

---

## âœ… Phase 4 â€” JS Bridge (`SolverBridge.js`)

### 4.1 â€” Unified API with lazy WASM loading

- [ ] **4.1.1** Create `shared/SolverBridge.js`
  ```javascript
  // SolverBridge.js
  // Provides a unified API that tries WASM first, falls back to JS.
  
  let wasmSolver = null;
  let wasmReady = false;
  let wasmFailed = false;
  
  export async function initWasm() {
      if (wasmReady || wasmFailed) return wasmReady;
      try {
          const wasm = await import('./solver-wasm/pkg/solver_wasm.js');
          await wasm.default(); // init WASM module
          wasmSolver = wasm;
          wasmReady = true;
          console.log('[SolverBridge] WASM solver loaded âœ“');
      } catch (e) {
          wasmFailed = true;
          console.warn('[SolverBridge] WASM unavailable, using JS fallback:', e.message);
      }
      return wasmReady;
  }
  
  export function isWasmReady() { return wasmReady; }
  ```

- [ ] **4.1.2** Implement `generateSolvableBoard()` bridge
  ```javascript
  export async function generateSolvableBoard(width, height, bombCount, safeX, safeY, noGuessMode, maxAttempts, onProgress) {
      if (wasmReady && noGuessMode) {
          // Entire loop in WASM â€” no per-iteration JS calls
          const safeRadius = noGuessMode ? 2 : 1;
          const result = wasmSolver.generate_solvable_board(
              width, height, bombCount, safeX, safeY, safeRadius, maxAttempts
          );
          return {
              mines: unflattenBoolArray(result.mines, width, height),
              grid: unflattenI8Array(result.grid, width, height),
              attempts: result.attempts,
              success: result.success,
          };
      }
      // Fallback: existing JS path (caller handles the loop)
      return null;
  }
  ```

- [ ] **4.1.3** Implement `getHint()` bridge
  ```javascript
  export function getHint(game) {
      if (wasmReady) {
          const result = wasmSolver.get_hint(
              flattenGrid(game.grid),
              flattenGrid(game.visibleGrid),
              flattenFlags(game.flags),
              flattenFlags(game.mines),
              game.width, game.height
          );
          return result; // { x, y, score, type } or null
      }
      // Fallback
      return MinesweeperSolver.getHint(game);
  }
  ```

- [ ] **4.1.4** Implement `isSolvable()` bridge
  ```javascript
  export function isSolvable(game, startX, startY) {
      if (wasmReady) {
          return wasmSolver.is_solvable(
              flattenGrid(game.grid), game.width, game.height,
              game.bombCount, startX, startY
          );
      }
      return MinesweeperSolver.isSolvable(game, startX, startY);
  }
  ```

- [ ] **4.1.5** Utility functions for array conversion
  ```javascript
  function flattenGrid(grid2d) { /* grid[x][y] â†’ Int8Array[x * height + y] */ }
  function flattenFlags(flags2d) { /* flags[x][y] â†’ Uint8Array[x * height + y] */ }
  function unflattenBoolArray(flat, w, h) { /* Uint8Array â†’ bool[][] */ }
  function unflattenI8Array(flat, w, h) { /* Int8Array â†’ number[][] */ }
  ```

**DoD:** `SolverBridge.js` exports a clean API. When WASM is available, it's used. When not (build not run, old browser), JS fallback works transparently.

---

## âœ… Phase 5 â€” Integration into Game Code

### 5.1 â€” Client-side (`javascripts/core/Game.js`)

- [ ] **5.1.1** Import and init WASM at app startup
  ```javascript
  // In main.js or Game.js
  import { initWasm } from '../../shared/SolverBridge.js';
  // Call early, non-blocking
  initWasm();
  ```

- [ ] **5.1.2** Modify `Game.placeMines()` to use bridge
  ```javascript
  async placeMines(safeX, safeY, onProgress) {
      // Try WASM path for no-guess mode (entire loop in WASM)
      if (this.noGuessMode) {
          const result = await generateSolvableBoard(
              this.width, this.height, this.bombCount,
              safeX, safeY, true, 10000, onProgress
          );
          if (result) {
              this.mines = result.mines;
              this.grid = result.grid;
              if (!result.success) return { warning: true };
              // Save for replay...
              return true;
          }
      }
      // Existing JS fallback path (unchanged)
      ...
  }
  ```

- [ ] **5.1.3** Modify `Game.getHint()` to use bridge
  ```javascript
  getHint() {
      if (this.gameOver || this.victory) return null;
      const hint = SolverBridge.getHint(this);
      if (hint) this.hintCount++;
      return hint;
  }
  ```

### 5.2 â€” Server-side (`server-multiplayer/Game.js`)

- [ ] **5.2.1** Load WASM in Node.js context
  - Node 20 supports WASM natively via `WebAssembly.instantiate()`
  - `wasm-pack build --target nodejs` generates Node-compatible bindings
  - Alternative: build a second target `--target nodejs` alongside `--target web`

- [ ] **5.2.2** Modify server `Game.placeMines()` to use bridge (same pattern as client)

- [ ] **5.2.3** Modify server `Game.getHint()` to use bridge

- [ ] **5.2.4** Build script produces both targets:
  ```bash
  # Browser target
  wasm-pack build --target web --out-dir pkg-web
  # Node.js target
  wasm-pack build --target nodejs --out-dir pkg-node
  ```

### 5.3 â€” Multiplayer-specific integration

- [ ] **5.3.1** `prePlaceMinesForMultiplayer()` â€” can use WASM `calculate_numbers()` for faster number computation
- [ ] **5.3.2** `placeMinesWithSafeZone()` â€” lightweight, probably not worth WASM-ifying (only runs once)

**DoD:** Both client and server use WASM when available. Fallback to JS works correctly. No behavioral differences.

---

## âœ… Phase 6 â€” Testing & Validation

### 6.1 â€” Equivalence testing

- [ ] **6.1.1** Create test harness that runs the same board through both JS and WASM solvers
  - Generate 200+ random boards (various sizes: 9Ã—9, 16Ã—16, 30Ã—16, 30Ã—20)
  - Compare `isSolvable()` result for each
  - Compare `getHint()` result for each  
  - All must match

- [ ] **6.1.2** Create Rust unit tests for each strategy
  ```bash
  cd shared/solver-wasm && cargo test
  ```
  - Test basic rules on hand-crafted boards
  - Test Gaussian elimination on known systems
  - Test contradiction on known contradiction scenarios
  - Test tank solver on small regions

- [ ] **6.1.3** Create JS integration tests
  ```javascript
  // test_wasm_solver.mjs
  import { initWasm, generateSolvableBoard, getHint } from '../shared/SolverBridge.js';
  import { MinesweeperSolver } from '../shared/MinesweeperSolver.js';
  // Compare outputs...
  ```

### 6.2 â€” Performance benchmarking

- [ ] **6.2.1** Benchmark `isSolvable()` â€” JS vs WASM on 30Ã—16 board with 99 mines
  - Run 100 iterations, measure average time
  - Target: **3Ã— faster** minimum

- [ ] **6.2.2** Benchmark `generateSolvableBoard()` â€” JS vs WASM
  - Measure total time for no-guess 30Ã—16/99 board gen
  - Target: **5Ã— faster** minimum

- [ ] **6.2.3** Benchmark on Raspberry Pi 3
  - SSH into raspberrol, run same benchmarks
  - Target: **10Ã— faster** on ARM (V8 JIT is weaker on ARM)

- [ ] **6.2.4** Measure WASM module load time
  - Browser: time from `import()` to `wasmReady = true`
  - Target: **< 200ms** for the `.wasm` file (~50-100KB expected)

### 6.3 â€” Edge case testing

- [ ] **6.3.1** Tiny boards (5Ã—5, 3 mines) â€” ensure no out-of-bounds
- [ ] **6.3.2** Maximum boards (50Ã—50, 500+ mines) â€” ensure no stack overflow in WASM
- [ ] **6.3.3** Unsolvable boards (no-guess mode hits max_attempts) â€” ensure gracefulè¿”å›
- [ ] **6.3.4** First-click safe zone near edges/corners
- [ ] **6.3.5** Multiplayer pre-placed mines â€” verify `calculateNumbers` matches

**DoD:** All equivalence tests pass. Performance targets met. Edge cases handled.

---

## âœ… Phase 7 â€” Build & Deployment

### 7.1 â€” CI/CD integration

- [ ] **7.1.1** Add WASM build step to deployment workflow
  - Pre-build WASM before `deploy.tar.gz` creation
  - Include `pkg-web/` and `pkg-node/` in deployment archive

- [ ] **7.1.2** Update `DEPLOYMENT.md` with WASM build instructions

### 7.2 â€” Raspberry Pi deployment

- [ ] **7.2.1** Cross-compile WASM on dev machine (not on RPi)
  - WASM is platform-agnostic â€” build once, run anywhere
  - No need for Rust toolchain on the RPi itself

- [ ] **7.2.2** Update deploy script to include `pkg-node/` directory

- [ ] **7.2.3** Test WASM loading on Node.js 20 on RPi
  ```bash
  ssh olivier@raspberrol "cd ~/minesweeper-server && node -e \"
    const wasm = require('./shared/solver-wasm/pkg-node/solver_wasm.js');
    console.log('WASM loaded:', typeof wasm.is_solvable);
  \""
  ```

### 7.3 â€” Browser deployment

- [ ] **7.3.1** Ensure `.wasm` file is served with correct MIME type (`application/wasm`)
  - GitHub Pages / Cloudflare Pages handle this automatically
  - If using custom server, add MIME type config

- [ ] **7.3.2** Add `shared/solver-wasm/pkg-web/` to the served static files

- [ ] **7.3.3** Verify WASM loads correctly on:
  - Chrome 90+ âœ“
  - Firefox 90+ âœ“
  - Safari 15+ âœ“
  - Edge 90+ âœ“

**DoD:** WASM is built, deployed, and loads on all targets. Fallback works on unsupported browsers.

---

## âœ… Phase 8 â€” Polish & Optimization (Optional)

- [ ] **8.1** Enable `wasm-opt` for smaller binary (`wasm-pack build --release`)
- [ ] **8.2** Profile with `perf` / `cargo flamegraph` to find remaining bottlenecks
- [ ] **8.3** Consider `wasm-bindgen-rayon` for multi-threaded solving (SharedArrayBuffer)
  - Would parallelize tank solver across regions
  - Requires `Cross-Origin-Isolation` headers (COOP/COEP)
- [ ] **8.4** Add HUD indicator showing "âš¡ WASM" when WASM solver is active
- [ ] **8.5** Investigate `simd128` target feature for RREF row operations
- [ ] **8.6** Consider `lto = true` and `codegen-units = 1` in `Cargo.toml` for max optimization

---

## ğŸ“Š Expected Results

| Metric | Current (JS) | Target (WASM) | Improvement |
|--------|-------------|--------------|-------------|
| `isSolvable()` â€” 30Ã—16 board | ~15-50ms | ~3-10ms | 3-5Ã— |
| Board gen (no-guess, 30Ã—16/99) | ~2-10s | ~200ms-1s | 5-15Ã— |
| Board gen on RPi 3 | ~5-30s | ~500ms-3s | 10-15Ã— |
| `getHint()` | ~5-20ms | ~1-5ms | 3-5Ã— |
| WASM module load | N/A | < 200ms | One-time cost |
| `.wasm` file size | N/A | ~50-100KB | Reasonable |

---

## ğŸ“ Files Modified / Created

### New Files
| File | Description |
|------|-------------|
| `shared/solver-wasm/Cargo.toml` | Rust crate config |
| `shared/solver-wasm/src/lib.rs` | WASM entry point |
| `shared/solver-wasm/src/types.rs` | Grid, VisibleGrid, Flags, NeighborCache |
| `shared/solver-wasm/src/board.rs` | Mine placement, number calculation |
| `shared/solver-wasm/src/solver.rs` | All 5+1 solving strategies |
| `shared/solver-wasm/src/gaussian.rs` | Gaussian Elimination (RREF) |
| `shared/solver-wasm/src/rng.rs` | WASM-compatible RNG |
| `shared/solver-wasm/tests/solver_tests.rs` | Rust unit tests |
| `shared/SolverBridge.js` | Unified JS API (WASM + fallback) |

### Modified Files
| File | Change |
|------|--------|
| `javascripts/core/Game.js` | Use `SolverBridge` for `placeMines()` and `getHint()` |
| `server-multiplayer/Game.js` | Use `SolverBridge` for `placeMines()` and `getHint()` |
| `javascripts/main.js` | Call `initWasm()` at startup |
| `.gitignore` | Add `solver-wasm/target/`, `solver-wasm/pkg*/` |
| `docs/ARCHITECTURE.md` | Document WASM integration |
| `DEPLOYMENT.md` | Add WASM build instructions |

### Untouched Files (JS Fallback)
| File | Status |
|------|--------|
| `shared/MinesweeperSolver.js` | **Kept as-is** â€” JS fallback |
| `shared/GaussianElimination.js` | **Kept as-is** â€” JS fallback |

---

## âš ï¸ Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| WASM binary too large | Slow first load | `wasm-opt -Oz`, lazy loading, cache with SW |
| Behavioral differences JSâ†”WASM | Bugs in production | Extensive equivalence testing (Phase 6) |
| RNG differences | Different boards | Seed-based RNG, matching algorithm |
| `SharedArrayBuffer` not available | No multi-threading | Single-threaded WASM is still 5Ã—+ faster |
| Rust learning curve | Development time | Solver logic is well-documented, 1:1 port |
| Node.js WASM support on RPi | Server won't load WASM | Node 20 has full WASM support; tested in Phase 7 |

---

*Created: 2026-02-11 â€” 3D Video Minesweeper Team*
