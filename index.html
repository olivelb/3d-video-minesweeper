<!DOCTYPE html>
<html lang="fr">

<head>
    <title>D√©mineur 3D - Modernis√©</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/style.css">

    <!-- Import Map pour r√©soudre 'three' dans les modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <!-- Vid√©o utilis√©e comme texture -->
    <video id="image" preload="auto" loop muted autoplay style="display:none;" playsinline>
        <source src="images/storm_render.mp4" type="video/mp4">
    </video>

    <div id="ui-container">
        <h1>D√©mineur 3D</h1>
        <p>Clic Gauche: R√©v√©ler | Clic Droit: Drapeau</p>
        <button id="mute-btn"
            style="position: absolute; top: 20px; right: 20px; background: none; border: 1px solid white; color: white; padding: 5px 10px; cursor: pointer;">üîä
            ON</button>
    </div>

    <div id="timer-display">‚è±Ô∏è 00:00</div>
    <div id="score-display">üèÜ Score: 0</div>

    <!-- Menu de d√©marrage -->
    <div id="menu-overlay">
        <div class="menu-box">
            <h2>Configuration</h2>
            <div class="input-group">
                <label>Largeur (Width)</label>
                <input type="number" id="grid-width" value="30" min="10" max="200">
            </div>
            <div class="input-group">
                <label>Hauteur (Height)</label>
                <input type="number" id="grid-height" value="20" min="10" max="150">
            </div>
            <div class="input-group">
                <label>Bombes</label>
                <input type="number" id="bomb-count" value="50" min="1">
            </div>
            <div class="input-group">
                <label>Vid√©o de fond (optionnel)</label>
                <div class="video-upload-container">
                    <input type="file" id="video-upload" accept="video/mp4,video/webm,video/ogg">
                    <label for="video-upload" class="video-upload-btn">
                        <span class="upload-icon">üìÅ</span>
                        <span class="upload-text">Choisir une vid√©o locale</span>
                    </label>
                    <span id="video-filename" class="video-filename">Par d√©faut: storm_render.mp4</span>
                </div>
                <div class="video-webcam">
                    <label class="webcam-label"><input type="checkbox" id="use-webcam"> Utiliser la webcam si
                        disponible</label>
                    <small class="hint">Si la webcam est refus√©e ou absente, on revient √† la vid√©o par d√©faut.</small>
                </div>
            </div>
            <button id="start-btn">JOUER</button>
        </div>
        
        <!-- Leaderboard -->
        <div class="leaderboard-box">
            <h2>üèÜ Meilleurs Scores</h2>
            <div id="leaderboard-list">
                <p class="no-scores">Aucun score enregistr√©</p>
            </div>
            <button id="clear-scores-btn" class="clear-btn">Effacer les scores</button>
        </div>
    </div>

    <div id="container"></div>

    <script type="module">
        import { MinesweeperGame } from './javascripts/Game.js';
        import { MinesweeperRenderer } from './javascripts/Renderer.js';
        import { ScoreManager } from './javascripts/ScoreManager.js';

        let game, renderer;
        const scoreManager = new ScoreManager();

        document.addEventListener('DOMContentLoaded', () => {
            const video = document.getElementById('image');
            const startBtn = document.getElementById('start-btn');
            const menuOverlay = document.getElementById('menu-overlay');
            const videoUpload = document.getElementById('video-upload');
            const videoFilename = document.getElementById('video-filename');
            const widthInput = document.getElementById('grid-width');
            const heightInput = document.getElementById('grid-height');
            const useWebcamCheckbox = document.getElementById('use-webcam');
            const clearScoresBtn = document.getElementById('clear-scores-btn');
            let customVideoUrl = null;
            let webcamStream = null;

            // Display leaderboard
            function updateLeaderboard() {
                const leaderboardList = document.getElementById('leaderboard-list');
                const topScores = scoreManager.getTopScores(10);
                
                if (topScores.length === 0) {
                    leaderboardList.innerHTML = '<p class="no-scores">Aucun score enregistr√©</p>';
                    return;
                }
                
                leaderboardList.innerHTML = topScores.map((score, index) => `
                    <div class="score-entry">
                        <div class="score-rank">#${index + 1}</div>
                        <div class="score-info">
                            <div class="score-value">${score.score.toLocaleString()} pts</div>
                            <div class="score-details">${score.width}x${score.height} | ${score.bombs} üí£ | ${scoreManager.formatTime(score.time)}</div>
                        </div>
                    </div>
                `).join('');
            }

            // Clear scores button
            clearScoresBtn.addEventListener('click', () => {
                if (confirm('√ätes-vous s√ªr de vouloir effacer tous les scores ?')) {
                    scoreManager.clearAllScores();
                    updateLeaderboard();
                }
            });

            // Initial leaderboard display
            updateLeaderboard();

            const stopWebcam = () => {
                if (webcamStream) {
                    webcamStream.getTracks().forEach(t => t.stop());
                    webcamStream = null;
                }
                if (video.srcObject) {
                    video.srcObject = null;
                }
            };

            const startWebcam = async () => {
                try {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return false;
                    webcamStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    video.srcObject = webcamStream;
                    video.muted = false;
                    video.removeAttribute('muted');
                    videoFilename.textContent = 'Webcam active';
                    videoFilename.classList.add('custom-video');
                    return true;
                } catch (err) {
                    console.warn('Webcam non disponible ou refus√©e:', err);
                    stopWebcam();
                    return false;
                }
            };

            // D√©tecter (grossi√®rement) la capacit√© GPU pour ajuster les limites
            const detectGpuTier = () => {
                const gl = document.createElement('canvas').getContext('webgl');
                if (!gl) return 'medium';
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';
                const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : '';
                const id = `${vendor} ${renderer}`.toLowerCase();

                // High tier examples: RTX 30/40, RX 6/7, Apple M-series
                const highPatterns = /(rtx 3|rtx 4|rx 6|rx 7|m1|m2|m3|m4)/;
                if (highPatterns.test(id)) return 'high';

                // Low tier examples: intel hd/uhd/iris older gens
                const lowPatterns = /(intel\s+(hd|uhd|iris))/;
                if (lowPatterns.test(id)) return 'low';

                return 'medium';
            };

            const gpuTier = detectGpuTier();
            const LIMITS = {
                high: { maxW: 200, maxH: 150 },
                medium: { maxW: 140, maxH: 100 },
                low: { maxW: 100, maxH: 80 }
            };
            const { maxW, maxH } = LIMITS[gpuTier] || LIMITS.medium;

            // Mettre √† jour les bornes des inputs selon la capacit√© d√©tect√©e
            widthInput.max = maxW;
            heightInput.max = maxH;

            // Handle video file upload
            videoUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    stopWebcam();
                    useWebcamCheckbox.checked = false;
                    // Revoke previous custom URL to free memory
                    if (customVideoUrl) {
                        URL.revokeObjectURL(customVideoUrl);
                    }
                    customVideoUrl = URL.createObjectURL(file);
                    video.src = customVideoUrl;
                    video.load();
                    videoFilename.textContent = file.name;
                    videoFilename.classList.add('custom-video');
                    video.muted = false;
                    video.removeAttribute('muted');
                }
            });

            // Toggle webcam usage
            useWebcamCheckbox.addEventListener('change', async (e) => {
                if (e.target.checked) {
                    // Clear any local file selection
                    videoUpload.value = '';
                    if (customVideoUrl) {
                        URL.revokeObjectURL(customVideoUrl);
                        customVideoUrl = null;
                    }
                    const ok = await startWebcam();
                    if (!ok) {
                        e.target.checked = false;
                    }
                } else {
                    stopWebcam();
                    // restore default label
                    videoFilename.textContent = 'Par d√©faut: storm_render.mp4';
                    videoFilename.classList.remove('custom-video');
                }
            });

            startBtn.addEventListener('click', async () => {
                // R√©cup√©rer les valeurs et les borner pour √©viter de saturer le GPU
                const MIN_DIM = 10;
                const MAX_W = parseInt(widthInput.max, 10) || 60;
                const MAX_H = parseInt(heightInput.max, 10) || 60;
                let width = parseInt(widthInput.value) || 30;
                let height = parseInt(heightInput.value) || 20;
                width = Math.min(Math.max(width, MIN_DIM), MAX_W);
                height = Math.min(Math.max(height, MIN_DIM), MAX_H);
                // R√©percuter les valeurs clamp√©es dans les inputs
                widthInput.value = width;
                heightInput.value = height;
                const bombs = parseInt(document.getElementById('bomb-count').value) || 50;

                // Choisir la source vid√©o (priorit√©: fichier local > webcam > d√©faut)
                if (videoUpload.files && videoUpload.files[0]) {
                    stopWebcam();
                    // Already handled in change event; ensure audio on
                    video.muted = false;
                    video.removeAttribute('muted');
                } else if (useWebcamCheckbox.checked) {
                    const ok = await startWebcam();
                    if (!ok) {
                        useWebcamCheckbox.checked = false;
                        // Fallback default video
                        if (customVideoUrl) {
                            URL.revokeObjectURL(customVideoUrl);
                            customVideoUrl = null;
                        }
                        video.crossOrigin = '';
                        video.src = 'images/storm_render.mp4';
                        video.load();
                        videoFilename.textContent = 'Par d√©faut: storm_render.mp4';
                        videoFilename.classList.remove('custom-video');
                        video.muted = false;
                        video.removeAttribute('muted');
                    }
                } else {
                    stopWebcam();
                    // Revenir √† la vid√©o par d√©faut
                    if (customVideoUrl) {
                        URL.revokeObjectURL(customVideoUrl);
                        customVideoUrl = null;
                    }
                    video.crossOrigin = '';
                    video.src = 'images/storm_render.mp4';
                    video.load();
                    videoFilename.textContent = 'Par d√©faut: storm_render.mp4';
                    videoFilename.classList.remove('custom-video');
                    video.muted = false;
                    video.removeAttribute('muted');
                }

                // Lancer la vid√©o
                video.play().catch(e => console.warn("Autoplay bloqu√©:", e));

                // Cacher le menu
                menuOverlay.style.display = 'none';

                // Nettoyer l'ancien jeu si n√©cessaire (pour futur restart)
                if (renderer) {
                    document.getElementById('container').innerHTML = '';
                }

                // Initialiser le jeu
                game = new MinesweeperGame(width, height, bombs);
                game.init();

                // Initialiser le rendu
                renderer = new MinesweeperRenderer(game, 'container', scoreManager);

                // Attendre que soundManager soit pr√™t (petit hack car init est async)
                setTimeout(() => {
                    if (renderer.soundManager) {
                        renderer.soundManager.resumeContext();
                        updateMuteState();
                    }
                }, 100);

                // Set callback for when game ends and should return to menu
                renderer.onGameEnd = () => {
                    renderer.dispose();
                    renderer = null;
                    game = null;
                    menuOverlay.style.display = 'flex';
                    updateLeaderboard(); // Refresh leaderboard with new score
                };
            });

            // Mute Button Logic
            const muteBtn = document.getElementById('mute-btn');
            let isMuted = false;

            function updateMuteState() {
                muteBtn.textContent = isMuted ? 'üîá OFF' : 'üîä ON';
                if (renderer && renderer.soundManager) {
                    renderer.soundManager.setMute(isMuted);
                }
            }

            muteBtn.addEventListener('click', () => {
                isMuted = !isMuted;
                updateMuteState();
            });
        });
    </script>
</body>

</html>