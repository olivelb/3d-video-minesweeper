<!DOCTYPE html>
<html lang="fr">

<head>
    <title>D√©mineur 3D - Multijoueur</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/drag-drop.css">

    <!-- Support HEIC -->
    <script src="https://unpkg.com/heic2any@0.0.4/dist/heic2any.min.js"></script>

    <!-- Import Map pour r√©soudre 'three' dans les modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script>
        window.MINESWEEPER_SERVERS = {
            raspberryCloud: 'https://maintain-machines-grace-print.trycloudflare.com'
        };
    </script>
</head>

<body>
    <!-- Vid√©o utilis√©e comme texture -->
    <video id="image" preload="auto" loop muted autoplay style="display:none;" playsinline>
        <source src="images/storm_render.mp4" type="video/mp4">
    </video>
    <!-- Image utilis√©e comme texture -->
    <img id="custom-image-source" style="display:none;" />

    <div id="ui-container">
        <h1>D√©mineur 3D</h1>
        <p>Clic Gauche: R√©v√©ler | Clic Droit: Drapeau</p>
        <button id="hint-btn" class="control-btn" title="Obtenir un indice logique">üß© BESOIN D'AIDE</button>
        <button id="flag-style-btn" class="control-btn" style="margin-left: 10px;"
            title="Basculer vers les drapeaux 3D">‚≠ê √âTOILES</button>
        <div id="hint-display">üß© Indices: 0</div>
        <button id="mute-btn" class="control-btn" title="D√©sactiver le son">üîä ON</button>
        <button id="retry-btn" title="Recommencer au dernier coup s√ªr">üîÅ REESSAYER</button>
    </div>

    <div id="timer-display">‚è±Ô∏è 00:00</div>
    <div id="score-display">üèÜ Score: 0</div>

    <!-- Menu de d√©marrage -->
    <div id="menu-overlay">
        <div class="menu-box">
            <h2>Configuration</h2>
            <div class="input-row">
                <div class="input-group">
                    <label>Largeur</label>
                    <input type="number" id="grid-width" value="30" min="10" max="200">
                </div>
                <div class="input-group">
                    <label>Hauteur</label>
                    <input type="number" id="grid-height" value="20" min="10" max="150">
                </div>
                <div class="input-group">
                    <label>Bombes</label>
                    <input type="number" id="bomb-count" value="50" min="1">
                </div>
            </div>
            <div class="input-group">
                <label>M√©dia de fond</label>
                <div id="background-presets-container" class="preset-grid">
                    <div class="preset-item active" data-value="video:images/storm_render.mp4" title="Orage (Vid√©o)">
                        <video src="images/storm_render.mp4" muted loop playsinline autoplay></video>
                        <span>Orage</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_5.png" title="Marbre Gris">
                        <img src="images/default_texture_5.png">
                        <span>Marbre</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_6.png" title="M√©tal Sombre">
                        <img src="images/default_texture_6.png">
                        <span>M√©tal</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_7.png" title="Bois Clair">
                        <img src="images/default_texture_7.png">
                        <span>Bois</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_8.png" title="Grille">
                        <img src="images/default_texture_8.png">
                        <span>Grille</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_9.png" title="Carbone">
                        <img src="images/default_texture_9.png">
                        <span>Carbone</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_1.png" title="N√©buleuse">
                        <img src="images/default_texture_1.png">
                        <span>Espace</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_2.png" title="Cristal">
                        <img src="images/default_texture_2.png">
                        <span>Cristal</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_3.png" title="N√©on">
                        <img src="images/default_texture_3.png">
                        <span>N√©on</span>
                    </div>
                    <div class="preset-item" data-value="image:images/default_texture_4.png" title="Fluide">
                        <img src="images/default_texture_4.png">
                        <span>Fluide</span>
                    </div>
                </div>

                <div class="video-upload-container">
                    <input type="file" id="video-upload" accept="video/mp4,video/webm,video/ogg,image/*,.heic,.heif">
                    <label for="video-upload" class="video-upload-btn">
                        <span class="upload-icon">üìÅ</span>
                        <span class="upload-text">Ou importer un fichier...</span>
                    </label>
                    <span id="video-filename" class="video-filename">Utilise le pr√©r√©glage ci-dessus</span>
                </div>

                <div class="video-webcam">
                    <label class="webcam-label"><input type="checkbox" id="use-webcam"> Utiliser la webcam</label>
                    <small class="hint">Si la webcam est refus√©e ou absente, on revient √† la vid√©o par d√©faut.</small>
                </div>
                <div class="input-row" style="margin-top: 15px;">
                    <div class="input-group">
                        <label class="checkbox-label"><input type="checkbox" id="hover-helper" checked> Aide au
                            survol</label>
                    </div>
                    <div class="input-group">
                        <label class="checkbox-label"><input type="checkbox" id="no-guess-mode"> Sans hasard (No
                            Guess)</label>
                    </div>
                </div>
            </div>

            <!-- Multiplayer Panel -->
            <div id="multiplayer-panel" class="panel">
                <h3>Multijoueur</h3>

                <!-- Server Status -->
                <div id="mp-server-status">
                    <span id="server-indicator">‚óè</span>
                    <span id="server-status-text">V√©rification du serveur...</span>
                </div>

                <!-- Connect to Server -->
                <div id="mp-connect">
                    <input type="text" id="server-name" placeholder="Votre pseudo" value="Joueur">
                    <button id="btn-connect-server" class="primary">Connexion</button>
                </div>

                <!-- Host Lobby (P1 creates game) -->
                <div id="mp-host-lobby" class="hidden">
                    <h4>üéÆ Cr√©er une partie</h4>
                    <div id="host-waiting" class="hidden">
                        <p>‚è≥ En attente d'un autre joueur...</p>
                    </div>
                    <div id="host-actions">
                        <button id="btn-create-game" class="primary">Cr√©er la partie</button>
                        <button id="btn-leave-host">Quitter</button>
                    </div>
                </div>

                <!-- Guest Lobby (P2 joins) -->
                <div id="mp-guest-lobby" class="hidden">
                    <h4>üéÆ Rejoindre</h4>
                    <div id="guest-waiting">
                        <p>‚è≥ En attente que l'h√¥te cr√©e la partie...</p>
                    </div>
                    <div id="guest-ready" class="hidden">
                        <p id="guest-config">Partie pr√™te !</p>
                        <button id="btn-join-game" class="primary">Rejoindre la partie</button>
                    </div>
                    <button id="btn-leave-guest">Quitter</button>
                </div>
            </div>

            <button id="replay-btn" style="display: none;">üîÑ REJOUER LA GRILLE</button>
            <button id="start-btn">JOUER (Solo)</button>
        </div>

        <!-- Leaderboard -->
        <div class="leaderboard-box">
            <h2>üèÜ Meilleurs Scores</h2>
            <div id="leaderboard-list">
                <p class="no-scores">Aucun score enregistr√©</p>
            </div>
            <button id="clear-scores-btn" class="clear-btn">Effacer les scores</button>
            <a href="analytics.html" class="analytics-link">üìä Analytics</a>
        </div>
    </div>

    <div id="loading-overlay" style="display:none;">
        <div class="loading-box">
            <h2>G√©n√©ration de la grille...</h2>
            <div class="spinner"></div>
            <p id="loading-text">Recherche d'une configuration valide...</p>
            <p id="loading-details" style="font-size: 0.9em; color: #888;">Tentative 0 / 10000</p>
            <button id="cancel-gen-btn" class="cancel-btn">ARR√äTER</button>
        </div>
    </div>

    <div id="container"></div>

    <script type="module">
        import { MinesweeperGame } from './javascripts/Game.js';
        import { MinesweeperRenderer } from './javascripts/Renderer.js';
        import { ScoreManager } from './javascripts/ScoreManager.js';
        import { UIManager } from './javascripts/UIManager.js';
        import { networkManager } from './javascripts/NetworkManager.js';

        let game, renderer;
        const scoreManager = new ScoreManager();
        let uiManager;

        document.addEventListener('DOMContentLoaded', () => {
            uiManager = new UIManager(null, null, scoreManager);
            window._minesweeperUIManager = uiManager;

            setupNetworkCallbacks();

            uiManager.onStartGame = (width, height, bombs, useHoverHelper, noGuessMode, bgName, replayMines, initialState) => {
                startGame(width, height, bombs, useHoverHelper, noGuessMode, bgName, replayMines, initialState);
            };

            // Timer/Score updates
            setInterval(() => {
                if (game && renderer) {
                    const timerDisplay = document.getElementById('timer-display');
                    const scoreDisplay = document.getElementById('score-display');
                    const hintDisplay = document.getElementById('hint-display');

                    if (game.gameStartTime) {
                        const time = game.getElapsedTime();
                        timerDisplay.textContent = `‚è±Ô∏è ${Math.floor(time / 60).toString().padStart(2, '0')}:${(time % 60).toString().padStart(2, '0')}`;
                        timerDisplay.classList.add('active');

                        const score = scoreManager.calculateScore(game.width, game.height, game.bombCount, time, {
                            noGuessMode: game.noGuessMode,
                            hintCount: game.hintCount,
                            retryCount: game.retryCount
                        });
                        scoreDisplay.textContent = `üèÜ Score: ${score.toLocaleString()}`;
                        scoreDisplay.classList.add('active');

                        hintDisplay.textContent = `üß© Indices: ${game.hintCount}`;
                        hintDisplay.classList.toggle('active', game.hintCount > 0);

                        const retryBtn = document.getElementById('retry-btn');
                        retryBtn.style.display = (game.gameOver && game.lastMove) ? 'block' : 'none';
                    } else {
                        timerDisplay.classList.remove('active');
                        scoreDisplay.classList.remove('active');
                        hintDisplay.classList.remove('active');
                    }
                }
            }, 100);
        });

        function startGame(width, height, bombs, useHoverHelper, noGuessMode, bgName, replayMines = null, initialState = null) {
            if (renderer) {
                renderer.dispose();
                renderer = null;
            }

            game = new MinesweeperGame(width, height, bombs);
            game.noGuessMode = noGuessMode;
            game.init();

            if (replayMines) {
                game.setMinesFromPositions(replayMines);
            }

            const videoElement = document.getElementById('image');
            if (videoElement && videoElement.src) {
                videoElement.play().catch(() => { });
            }

            renderer = new MinesweeperRenderer(game, 'container', scoreManager, useHoverHelper, bgName);

            // If we have an initial state (multiplayer join), apply it immediately
            if (initialState) {
                applyStateSync(initialState);
            }

            const hintBtn = document.getElementById('hint-btn');
            hintBtn.style.display = 'inline-flex';
            hintBtn.onclick = () => {
                const hint = game.getHint();
                if (hint) {
                    renderer.showHint(hint.x, hint.y, hint.type);
                } else {
                    hintBtn.classList.add('no-hint');
                    setTimeout(() => hintBtn.classList.remove('no-hint'), 500);
                }
            };

            const retryBtn = document.getElementById('retry-btn');
            retryBtn.onclick = () => {
                if (game.retryLastMove()) {
                    renderer.resetExplosion();
                    retryBtn.style.display = 'none';
                    document.getElementById('hint-btn').style.display = 'block';
                }
            };

            uiManager.setRenderer(renderer);

            setTimeout(() => {
                if (renderer.soundManager) {
                    renderer.soundManager.resumeContext();
                    renderer.soundManager.setMute(uiManager.isMuted);
                }
            }, 100);

            renderer.onGameEnd = () => {
                document.getElementById('hint-btn').style.display = 'none';
                document.getElementById('retry-btn').style.display = 'none';
                renderer.dispose();
                renderer = null;
                game = null;
                uiManager.showMenu();
            };
        }

        function setupNetworkCallbacks() {
            networkManager.onConnected = () => console.log('[Main] Connected to server');
            networkManager.onPlayerJoined = (data) => console.log('[Main] Player joined:', data);
            networkManager.onPlayerLeft = (data) => console.log('[Main] Player left:', data);
            networkManager.onGameReady = (config) => console.log('[Main] Game ready:', config);

            networkManager.onStateSync = async (state) => {
                if (!state) return;

                if (!game || !renderer) {
                    // This case handles joining an already running game via onStateSync message
                    // (if not already handled by onGameStart)
                    startGame(state.width, state.height, state.bombCount, true, false, 'Multiplayer', state.minePositions, state);
                } else {
                    applyStateSync(state);
                }
            };

            function applyStateSync(state) {
                if (!game || !state || !renderer) return;

                game.visibleGrid = state.visibleGrid.map(row => [...row]);
                game.flags = state.flags.map(row => [...row]);
                game.gameOver = state.gameOver;
                game.victory = state.victory;

                renderer.numberMeshes.forEach(mesh => {
                    renderer.scene.remove(mesh);
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) {
                        if (mesh.material.map) mesh.material.map.dispose();
                        mesh.material.dispose();
                    }
                });
                renderer.numberMeshes = [];

                for (let x = 0; x < game.width; x++) {
                    for (let y = 0; y < game.height; y++) {
                        const index = x * game.height + y;
                        renderer.dummy.position.set(-(game.width * 10) + x * 22, 0, (game.height * 10) - y * 22);
                        renderer.dummy.rotation.set(-Math.PI / 2, 0, 0);
                        renderer.dummy.scale.set(game.visibleGrid[x][y] !== -1 ? 0 : 1, game.visibleGrid[x][y] !== -1 ? 0 : 1, game.visibleGrid[x][y] !== -1 ? 0 : 1);
                        renderer.dummy.updateMatrix();
                        renderer.gridMesh.setMatrixAt(index, renderer.dummy.matrix);
                    }
                }
                renderer.gridMesh.instanceMatrix.needsUpdate = true;

                for (let x = 0; x < game.width; x++) {
                    for (let y = 0; y < game.height; y++) {
                        const val = game.visibleGrid[x][y];
                        if (val !== -1 && val > 0) {
                            const planeGeo = new THREE.PlaneGeometry(16, 16);
                            const material = new THREE.MeshBasicMaterial({
                                map: renderer.textures[val],
                                transparent: true, opacity: 1.0, depthWrite: true, depthTest: true,
                                side: THREE.DoubleSide, alphaTest: 0.1
                            });
                            const mesh = new THREE.Mesh(planeGeo, material);
                            mesh.position.set(-(game.width * 10) + x * 22, 11, (game.height * 10) - y * 22);
                            mesh.rotation.x = -Math.PI / 2;
                            mesh.renderOrder = 1;
                            renderer.scene.add(mesh);
                            renderer.numberMeshes.push(mesh);
                        }
                        if (game.flags[x][y]) renderer.updateFlagVisual(x, y, true);
                    }
                }
            }

            networkManager.onGameUpdate = (update) => {
                console.log('[Main] gameUpdate received:', update);
                if (!game || !renderer) {
                    console.log('[Main] No game/renderer, ignoring update');
                    return;
                }
                const result = update.result;
                console.log('[Main] Processing result type:', result.type, 'changes:', result.changes?.length);
                if (result.type === 'reveal' || result.type === 'win') {
                    // Update local game state AND visuals
                    result.changes.forEach(c => {
                        game.visibleGrid[c.x][c.y] = c.value; // Update game state
                        renderer.updateCellVisual(c.x, c.y, c.value);
                    });
                    if (result.type === 'win') { game.victory = true; renderer.triggerWin(); }
                } else if (result.type === 'explode') {
                    game.gameOver = true;
                    game.visibleGrid[update.action.x][update.action.y] = 9; // Mark explosion
                    renderer.triggerExplosion();
                } else if (result.type === 'flag') {
                    game.flags[result.x][result.y] = result.active;
                    renderer.updateFlagVisual(result.x, result.y, result.active);
                }
            };

            networkManager.onGameOver = (data) => {
                if (!game) return;
                console.log('[Main] Game Over received:', data);
                if (data.victory) {
                    game.victory = true;
                    renderer.triggerWin();
                } else {
                    game.gameOver = true;
                    renderer.triggerExplosion();
                }
                // Server will send gameEnded after delay, which will return to menu
            };

            networkManager.onMinesPlaced = (minePositions) => {
                if (!game || !minePositions) return;
                console.log('[Main] Mines placed:', minePositions.length, 'mines');
                game.setMinesFromPositions(minePositions);
            };

            // Server tells us the game session is over, return to menu
            networkManager.onGameEnded = () => {
                console.log('[Main] Game ended, returning to menu');
                networkManager.disconnect();
                if (renderer) {
                    renderer.dispose();
                    renderer = null;
                }
                game = null;
                uiManager.showMenu();
                // Reset multiplayer panel to initial state completely
                document.getElementById('mp-connect').classList.remove('hidden');
                document.getElementById('mp-host-lobby').classList.add('hidden');
                document.getElementById('mp-guest-lobby').classList.add('hidden');
                // Reset host lobby internal state
                document.getElementById('host-waiting').classList.add('hidden');
                document.getElementById('host-actions').classList.remove('hidden');
                // Reset guest lobby internal state
                document.getElementById('guest-waiting').classList.remove('hidden');
                document.getElementById('guest-ready').classList.add('hidden');
            };

            networkManager.onCursorUpdate = (cursor) => {
                if (renderer && cursor.playerNumber !== networkManager.playerNumber) {
                    renderer.updatePartnerCursor(cursor.x, cursor.y);
                }
            };

            networkManager.onError = (error) => {
                console.error('[Main] Network error:', error);
                alert('Erreur r√©seau: ' + error);
            };
        }
    </script>
</body>

</html>